# kafka-prod-cons

Here’s a **clean, simple, human-written README** that looks natural and practical — not like it was generated by an AI.
You can directly paste this into your repo.

---

# **README.md**

## Event-Driven Microservices with Spring Boot & Apache Kafka

This project is a minimal but realistic implementation of event-driven communication using two Spring Boot microservices and a local Kafka setup (running in Docker).
The goal was to understand how services can communicate asynchronously through events rather than direct REST calls.

---

## **Project Overview**

The system consists of two services:

1. **order-service**

   * Exposes a REST API.
   * Publishes `OrderEvent` messages (JSON) to a Kafka topic.

2. **payment-service**

   * Listens to the same Kafka topic.
   * Automatically receives and processes the events.

Kafka acts as the message broker between these services.
A Kafka UI Dashboard is also included for monitoring topics and messages.

---

## **Architecture**

```
(order-service)  -->  [Kafka Topic: orders]  -->  (payment-service)
```

* The producer sends JSON messages using `KafkaTemplate`
* The consumer listens using `@KafkaListener`
* JSON serialization/deserialization is handled by Spring Kafka
* Kafka, Zookeeper, and Kafka UI run via docker-compose

---

## **Key Learnings**

* How to structure microservices around events instead of REST calls
* Using Spring Kafka’s JSON serializer/deserializer with custom DTOs
* Working with Kafka topics, partitions, consumer groups, and offsets
* Running Kafka locally using Docker (Confluent Community images)
* Debugging Kafka via CLI and Kafka UI Dashboard
* Understanding real-world async communication patterns

---

## **Tech Stack**

* Java 17
* Spring Boot
* Spring Kafka
* Apache Kafka (self-hosted via Docker)
* Kafka UI (Provectus)
* Maven

---

## **Kafka Setup (Docker)**

This repository contains a `docker-compose.yml` that spins up:

* Zookeeper
* Kafka broker
* Kafka UI Dashboard

### Start Kafka

```bash
docker compose up -d
```

### Stop Kafka

```bash
docker compose down
```

---

## **Useful Kafka Commands**

### Create the topic

```bash
docker exec -it kafka kafka-topics \
  --bootstrap-server kafka:9092 \
  --create --topic orders \
  --partitions 1 \
  --replication-factor 1
```

### List topics

```bash
docker exec -it kafka kafka-topics \
  --bootstrap-server kafka:9092 \
  --list
```

### Consume messages (manual test)

```bash
docker exec -it kafka kafka-console-consumer \
  --bootstrap-server kafka:9092 \
  --topic orders \
  --from-beginning
```

---

## **Kafka UI (Dashboard)**

After running the containers, open:

**[http://localhost:8080](http://localhost:8080)**

This dashboard lets you check messages, partitions, consumer groups, offsets, etc.

---

## **Running the Microservices**

### 1. Start the consumer first (payment-service)

```bash
cd payment-service
mvn spring-boot:run
```

### 2. Then start the producer (order-service)

```bash
cd order-service
mvn spring-boot:run
```

---

## **Testing the Flow**

Send a POST request to create an order:

```
POST http://localhost:8081/api/order/create
```

JSON body:

```json
{
  "orderId": "101",
  "userId": "U1",
  "amount": 500
}
```

### Expected output in payment-service logs:

```
Payment service received ORDER event:
Order ID: 101
User ID: U1
Amount: 500.0
Status: CREATED
```

---

## **Folder Structure**

```
.
├── order-service/
├── payment-service/
├── docker-compose.yml
└── README.md
```

---

## **Future Improvements**

* Add Schema Registry (Avro or JSON Schema)
* Add Kafka Streams for event processing
* Add more services (Notification, Inventory, etc.)
* Convert to a multi-broker Kafka cluster
* Implement a simple Saga workflow
